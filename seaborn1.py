# -*- coding: utf-8 -*-
"""Seaborn1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19XZ4Ba2mlTHn0phDKO9S2OlsrpBxD88s
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# load a built in dataset based on US state car crash percentages
crash_df=sns.load_dataset('car_crashes')

# distribution plot
# provides a way to look at a univariate disribution.A
# univariate distribution provides a distribution for one variable

sns.displot(crash_df["not_distracted"],kde=False,bins=25)

# joint plot
# jointplot compares 2 distribution and plots a scatter plot by default
# as we can see as people tend to speed they also tend to drink & drive
sns.jointplot(x="speeding",y="alcohol",data=crash_df,kind='reg')

# KDE PLOT
# A kernal density estimate (KDE) plot is a method for visualizing the distribution of observation in a dataset,analogous to a histogram.
# Get just teh kde plot
sns.kdeplot(crash_df["alcohol"])

# pair plots
# pair plot plots relationships across teh entire data frames numerical values
sns.pairplot(crash_df)

# load data on tips
tips_df=sns.load_dataset('tips')

# Rug plots

#plots a single column of datapoints in an array as sticks on an axis
# with a rug plot you'll see a more dense number of lines where the amount is 
# most common. This is like how a histogram is taller where values where values are more common
sns.rugplot(tips_df["tip"])

# Styling
# you can set styling for your axes and grids
# white,darkgrid,whitegrid,dark,ticks
sns.set_style('white')

# you can use figure sizing from matplotlib
plt.figure(figsize=(8,4))

# change size of labels,lines and other elements to best fit
# how you will present your data (paper,talk,poster)
sns.set_context("paper",font_scale=1.4)

sns.jointplot(x="speeding",y="alcohol",data=crash_df,kind="reg")

# Get rid of spines
# You can turn of specific spines with right=True,left=True
# bottom=True,top=true
sns.despine(left=False,bottom=False)

#categorial plots
# bar plots

# focus on distribution using categorial data in reference to one of the numerical 
# columns

# aggregate categorial data based on a function (mean is the default)
# estimate total bill amount based on sex
# with estimator you can define function to use other than the mean like those
# provided by numpy:median,std,var,cov or make your own functions
sns.barplot(x="sex",y='total_bill',data=tips_df,estimator=np.median)

# count plot

# A count plot is like a bar plot,but the estimator is counting
# the number of occurances
sns.countplot(x="sex",data=tips_df)

# box plot
plt.figure(figsize=(14,9))
sns.set_style("darkgrid")

# A box plot allows you to compare different variables
# teh box shows the quartiles of the data.the bar in the middle is the median and 
# the box extends 1 standard deviation from the median
# the whiskers extend to all the other data aside from the points that are considered
# to be outliers
# hue can add another category being sex
# we see men spend way more on friday versus less than woman on saturday
sns.boxplot(x='day',y='total_bill',data=tips_df,hue='sex')

# moves legend to the best position 
plt.legend(loc=0)

# Violin plot is a combination of the boxplot and KDE
#While a box plot corresponds to data points, the violins plots uses the KDE estimation
# of the data points
# split allows you to compare how the categories compare to each other
sns.violinplot(x='day',y="total_bill",data=tips_df,hue="sex",split=True)

# strip plot
plt.figure(figsize=(8,5))

#the strip plot draws a scatter plot representing all data points where one
# variable is categorial.it is often used to show all observation with
# a box plot that represents the average distribution
# jitter spreads data points  out so that they aren't stacked on top of each other
# hue breaks data into men and women
# dodge seperates the men and women data
sns.stripplot(x='day',y='total_bill',data=tips_df,jitter=True,
              hue='sex',dodge=True)

# Swarm plot

# swarm plot is like a strip plot, but points are adjusted so they don't overlap
# it looks like a combination of the violin and strip plots
# sns.swarmplot(x='day',y='total_bill',data=tips_df)

# you can stack a violin plot with a swarm
sns.violinplot(x='day',y='total_bill',data=tips_df)
sns.swarmplot(x='day',y='total_bill',data=tips_df,color='white')

# palettes
plt.figure(figsize=(8,6))
sns.set_style("dark")
sns.set_context("talk")

 # you can use matplotlib color maps for color styling
sns.stripplot(x='day',y='total_bill',data=tips_df,hue='sex',
               palette='seismic')

#add the optional legend with a location number (best:0,
# upper right:1, upper left:2, lower right:4, 
# https://matplotlib.org/3.3.1/api/_as_gen/matplotlib.pyplot.legend.html)
# or supply a tuple of x & y from lower left
plt.legend(loc=0)

# Facet Grid
 # can also print multiple plots in a grid in which you define columns & rows
 # get histogram for smokers and non with total bill for lunch & dinner
 # tips_fg=sns.facetgrid(tips_df,col='time',row='smoker')
  
# you can pass in attributes for the histogram
# tips_fg.map(plt.hist,"total_bill",bins=8)

#create a scatter plot with data on total bill & tip (you need to parameters)
#tips_fg.map(plt.scatter,"total_bill","tip")

# we can assign variables to differnt colors and increase size of grid
# aspect is 1.3 x the size of the height
# you can change the order of the columns
# define the palette used
# tips_fg=sns.facetgrid(tips_df,col='time',hue='smoker',height=4,aspect=1.3,
#                       col_order=['dinner','lunch'],palette='set1')
# tips_fg.map(plt.scatter,"total_bill","tip",edgecolor="w")

# define size,linewidth and assign a color of white markers
# kws=dict(s=50,linewidth=5,edgecolor="w")
# define that we want to assign different markers to smokers and non
# tips_fg=sns.facetgrid(tips_df,col='sex',hue='smoker',height=4,aspect=1.3,
#                       hue_order=["yes","no"],
#                       hue_kws=dict(marker=['^','v']))
# tips_fg.map(plt.scatter,"total_bill","tip",**kws)
# tips_fg.add_legend()

# this dataframe provides scores for differnt students based on the level
# of attention they could provide during testing
att_df=sns.load_dataset("attention")
# put each person in their own plot with 5 per line and plot their scores
att_fg=sns.FacetGrid(att_df,col='subject',col_wrap=5,height=1.5)
att_fg.map(plt.plot, 'solutions', 'score',marker='.')



